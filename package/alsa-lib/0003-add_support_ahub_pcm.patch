From 5362ecbaff2e1c74cad5ec9e5e45afa9d10bd33e Mon Sep 17 00:00:00 2001
From: yumingfeng <yumingfeng@allwinnertech.com>
Date: Fri, 4 Dec 2020 15:42:59 +0800
Subject: [PATCH] add_support_ahub_pcm
To: yumingfeng <yumingfeng@allwinnertech.com>
Cc: yumingfeng <yumingfeng@allwinnertech.com>

Signed-off-by: yumingfeng <yumingfeng@allwinnertech.com>
---
 include/tinyalsa/asoundlib.h |  327 +++++++++
 src/pcm/Makefile.am          |    2 +-
 src/pcm/Makefile.in          |   70 +-
 src/pcm/pcm_hw.c             |  137 +++-
 src/pcm/pcm_tinyalsa.c       | 1519 ++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 2016 insertions(+), 39 deletions(-)
 create mode 100644 include/tinyalsa/asoundlib.h
 create mode 100644 src/pcm/pcm_tinyalsa.c

diff --git a/include/tinyalsa/asoundlib.h b/include/tinyalsa/asoundlib.h
new file mode 100644
index 0000000..1f69d85
--- /dev/null
+++ b/include/tinyalsa/asoundlib.h
@@ -0,0 +1,327 @@
+/* asoundlib.h
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#ifndef ASOUNDLIB_H
+#define ASOUNDLIB_H
+
+#include <sys/time.h>
+#include <stddef.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*
+ * PCM API
+ */
+
+struct pcm;
+
+#define PCM_OUT        0x00000000
+#define PCM_IN         0x10000000
+#define PCM_MMAP       0x00000001
+#define PCM_NOIRQ      0x00000002
+#define PCM_NORESTART  0x00000004 /* PCM_NORESTART - when set, calls to
+                                   * pcm_write for a playback stream will not
+                                   * attempt to restart the stream in the case
+                                   * of an underflow, but will return -EPIPE
+                                   * instead.  After the first -EPIPE error, the
+                                   * stream is considered to be stopped, and a
+                                   * second call to pcm_write will attempt to
+                                   * restart the stream.
+                                   */
+#define PCM_MONOTONIC  0x00000008 /* see pcm_get_htimestamp */
+
+/* PCM runtime states */
+#define	PCM_STATE_OPEN		0
+#define	PCM_STATE_SETUP		1
+#define	PCM_STATE_PREPARED	2
+#define	PCM_STATE_RUNNING		3
+#define	PCM_STATE_XRUN		4
+#define	PCM_STATE_DRAINING	5
+#define	PCM_STATE_PAUSED		6
+#define	PCM_STATE_SUSPENDED	7
+#define	PCM_STATE_DISCONNECTED	8
+
+/* TLV header size*/
+#define TLV_HEADER_SIZE (2 * sizeof(unsigned int))
+
+/* Bit formats */
+enum pcm_format {
+    PCM_FORMAT_INVALID = -1,
+    PCM_FORMAT_S16_LE = 0,  /* 16-bit signed */
+    PCM_FORMAT_S32_LE,      /* 32-bit signed */
+    PCM_FORMAT_S8,          /* 8-bit signed */
+    PCM_FORMAT_S24_LE,      /* 24-bits in 4-bytes */
+    PCM_FORMAT_S24_3LE,     /* 24-bits in 3-bytes */
+
+    PCM_FORMAT_MAX,
+};
+
+/* Bitmask has 256 bits (32 bytes) in asound.h */
+struct pcm_mask {
+    unsigned int bits[32 / sizeof(unsigned int)];
+};
+
+/* Configuration for a stream */
+struct pcm_config {
+    unsigned int channels;
+    unsigned int rate;
+    unsigned int period_size;
+    unsigned int period_count;
+    enum pcm_format format;
+
+    /* Values to use for the ALSA start, stop and silence thresholds, and
+     * silence size.  Setting any one of these values to 0 will cause the
+     * default tinyalsa values to be used instead.
+     * Tinyalsa defaults are as follows.
+     *
+     * start_threshold   : period_count * period_size
+     * stop_threshold    : period_count * period_size
+     * silence_threshold : 0
+     * silence_size      : 0
+     */
+    unsigned int start_threshold;
+    unsigned int stop_threshold;
+    unsigned int silence_threshold;
+    unsigned int silence_size;
+
+    /* Minimum number of frames available before pcm_mmap_write() will actually
+     * write into the kernel buffer. Only used if the stream is opened in mmap mode
+     * (pcm_open() called with PCM_MMAP flag set).   Use 0 for default.
+     */
+    int avail_min;
+};
+
+/* PCM parameters */
+enum pcm_param
+{
+    /* mask parameters */
+    PCM_PARAM_ACCESS,
+    PCM_PARAM_FORMAT,
+    PCM_PARAM_SUBFORMAT,
+    /* interval parameters */
+    PCM_PARAM_SAMPLE_BITS,
+    PCM_PARAM_FRAME_BITS,
+    PCM_PARAM_CHANNELS,
+    PCM_PARAM_RATE,
+    PCM_PARAM_PERIOD_TIME,
+    PCM_PARAM_PERIOD_SIZE,
+    PCM_PARAM_PERIOD_BYTES,
+    PCM_PARAM_PERIODS,
+    PCM_PARAM_BUFFER_TIME,
+    PCM_PARAM_BUFFER_SIZE,
+    PCM_PARAM_BUFFER_BYTES,
+    PCM_PARAM_TICK_TIME,
+};
+
+/* Mixer control types */
+enum mixer_ctl_type {
+    MIXER_CTL_TYPE_BOOL,
+    MIXER_CTL_TYPE_INT,
+    MIXER_CTL_TYPE_ENUM,
+    MIXER_CTL_TYPE_BYTE,
+    MIXER_CTL_TYPE_IEC958,
+    MIXER_CTL_TYPE_INT64,
+    MIXER_CTL_TYPE_UNKNOWN,
+
+    MIXER_CTL_TYPE_MAX,
+};
+
+/* Open and close a stream */
+struct pcm *pcm_fmode_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config, int fmode);
+struct pcm *pcm_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config);
+int pcm_close(struct pcm *pcm);
+int pcm_is_ready(struct pcm *pcm);
+
+/* Obtain the parameters for a PCM */
+struct pcm_params *pcm_params_get(unsigned int card, unsigned int device,
+                                  unsigned int flags);
+void pcm_params_free(struct pcm_params *pcm_params);
+
+struct pcm_mask *pcm_params_get_mask(struct pcm_params *pcm_params,
+                                     enum pcm_param param);
+unsigned int pcm_params_get_min(struct pcm_params *pcm_params,
+                                enum pcm_param param);
+void pcm_params_set_min(struct pcm_params *pcm_params,
+                                enum pcm_param param, unsigned int val);
+unsigned int pcm_params_get_max(struct pcm_params *pcm_params,
+                                enum pcm_param param);
+void pcm_params_set_max(struct pcm_params *pcm_params,
+                                enum pcm_param param, unsigned int val);
+
+/* Converts the pcm parameters to a human readable string.
+ * The string parameter is a caller allocated buffer of size bytes,
+ * which is then filled up to size - 1 and null terminated,
+ * if size is greater than zero.
+ * The return value is the number of bytes copied to string
+ * (not including null termination) if less than size; otherwise,
+ * the number of bytes required for the buffer.
+ */
+int pcm_params_to_string(struct pcm_params *params, char *string, unsigned int size);
+
+/* Returns 1 if the pcm_format is present (format bit set) in
+ * the pcm_params structure; 0 otherwise, or upon unrecognized format.
+ */
+int pcm_params_format_test(struct pcm_params *params, enum pcm_format format);
+
+/* Set and get config */
+int pcm_get_config(struct pcm *pcm, struct pcm_config *config);
+int pcm_set_config(struct pcm *pcm, struct pcm_config *config);
+
+/* Returns a human readable reason for the last error */
+const char *pcm_get_error(struct pcm *pcm);
+
+/* Returns the sample size in bits for a PCM format.
+ * As with ALSA formats, this is the storage size for the format, whereas the
+ * format represents the number of significant bits. For example,
+ * PCM_FORMAT_S24_LE uses 32 bits of storage.
+ */
+unsigned int pcm_format_to_bits(enum pcm_format format);
+
+/* Returns the buffer size (int frames) that should be used for pcm_write. */
+unsigned int pcm_get_buffer_size(struct pcm *pcm);
+unsigned int pcm_frames_to_bytes(struct pcm *pcm, unsigned int frames);
+unsigned int pcm_bytes_to_frames(struct pcm *pcm, unsigned int bytes);
+
+/* Returns the pcm latency in ms */
+unsigned int pcm_get_latency(struct pcm *pcm);
+
+/* Returns available frames in pcm buffer and corresponding time stamp.
+ * The clock is CLOCK_MONOTONIC if flag PCM_MONOTONIC was specified in pcm_open,
+ * otherwise the clock is CLOCK_REALTIME.
+ * For an input stream, frames available are frames ready for the
+ * application to read.
+ * For an output stream, frames available are the number of empty frames available
+ * for the application to write.
+ */
+int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
+                       struct timespec *tstamp);
+
+/* Returns the subdevice on which the pcm has been opened */
+unsigned int pcm_get_subdevice(struct pcm *pcm);
+
+/* Write data to the fifo.
+ * Will start playback on the first write or on a write that
+ * occurs after a fifo underrun.
+ */
+int pcm_write(struct pcm *pcm, const void *data, unsigned int count);
+int pcm_read(struct pcm *pcm, void *data, unsigned int count);
+
+/*
+ * mmap() support.
+ */
+int pcm_mmap_write(struct pcm *pcm, const void *data, unsigned int count);
+int pcm_mmap_read(struct pcm *pcm, void *data, unsigned int count);
+int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
+                   unsigned int *frames);
+int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames);
+int pcm_mmap_avail(struct pcm *pcm);
+
+/* Returns current read/write position in the mmap buffer with associated time stamp.
+ */
+int pcm_mmap_get_hw_ptr(struct pcm* pcm, unsigned int *hw_ptr, struct timespec *tstamp);
+
+/* Prepare the PCM substream to be triggerable */
+int pcm_prepare(struct pcm *pcm);
+/* Start and stop a PCM channel that doesn't transfer data */
+int pcm_start(struct pcm *pcm);
+int pcm_stop(struct pcm *pcm);
+
+/* ioctl function for PCM driver */
+int pcm_ioctl(struct pcm *pcm, int request, ...);
+
+/* Interrupt driven API */
+int pcm_wait(struct pcm *pcm, int timeout);
+int pcm_get_poll_fd(struct pcm *pcm);
+
+/* Change avail_min after the stream has been opened with no need to stop the stream.
+ * Only accepted if opened with PCM_MMAP and PCM_NOIRQ flags
+ */
+int pcm_set_avail_min(struct pcm *pcm, int avail_min);
+
+/*
+ * MIXER API
+ */
+
+struct mixer;
+struct mixer_ctl;
+
+/* Open and close a mixer */
+struct mixer *mixer_open(unsigned int card);
+void mixer_close(struct mixer *mixer);
+
+/* Get info about a mixer */
+const char *mixer_get_name(struct mixer *mixer);
+
+/* Obtain mixer controls */
+unsigned int mixer_get_num_ctls(struct mixer *mixer);
+struct mixer_ctl *mixer_get_ctl(struct mixer *mixer, unsigned int id);
+struct mixer_ctl *mixer_get_ctl_by_name(struct mixer *mixer, const char *name);
+
+/* Get info about mixer controls */
+const char *mixer_ctl_get_name(struct mixer_ctl *ctl);
+enum mixer_ctl_type mixer_ctl_get_type(struct mixer_ctl *ctl);
+const char *mixer_ctl_get_type_string(struct mixer_ctl *ctl);
+unsigned int mixer_ctl_get_num_values(struct mixer_ctl *ctl);
+unsigned int mixer_ctl_get_num_enums(struct mixer_ctl *ctl);
+const char *mixer_ctl_get_enum_string(struct mixer_ctl *ctl,
+                                      unsigned int enum_id);
+
+/* Some sound cards update their controls due to external events,
+ * such as HDMI EDID byte data changing when an HDMI cable is
+ * connected. This API allows the count of elements to be updated.
+ */
+void mixer_ctl_update(struct mixer_ctl *ctl);
+
+/* Set and get mixer controls */
+int mixer_ctl_get_percent(struct mixer_ctl *ctl, unsigned int id);
+int mixer_ctl_set_percent(struct mixer_ctl *ctl, unsigned int id, int percent);
+
+int mixer_ctl_get_value(struct mixer_ctl *ctl, unsigned int id);
+int mixer_ctl_is_access_tlv_rw(struct mixer_ctl *ctl);
+int mixer_ctl_get_array(struct mixer_ctl *ctl, void *array, size_t count);
+int mixer_ctl_set_value(struct mixer_ctl *ctl, unsigned int id, int value);
+int mixer_ctl_set_array(struct mixer_ctl *ctl, const void *array, size_t count);
+int mixer_ctl_set_enum_by_string(struct mixer_ctl *ctl, const char *string);
+
+/* Determine range of integer mixer controls */
+int mixer_ctl_get_range_min(struct mixer_ctl *ctl);
+int mixer_ctl_get_range_max(struct mixer_ctl *ctl);
+
+int mixer_subscribe_events(struct mixer *mixer, int subscribe);
+int mixer_wait_event(struct mixer *mixer, int timeout);
+int mixer_consume_event(struct mixer *mixer);
+
+#if defined(__cplusplus)
+}  /* extern "C" */
+#endif
+
+#endif
diff --git a/src/pcm/Makefile.am b/src/pcm/Makefile.am
index 8edbd0b..8488dc1 100644
--- a/src/pcm/Makefile.am
+++ b/src/pcm/Makefile.am
@@ -3,7 +3,7 @@ DIST_SUBDIRS = scopes
 
 EXTRA_LTLIBRARIES = libpcm.la
 
-libpcm_la_SOURCES = mask.c interval.c \
+libpcm_la_SOURCES = mask.c interval.c pcm_tinyalsa.c \
 		    pcm.c pcm_params.c pcm_simple.c \
 		    pcm_hw.c pcm_misc.c pcm_mmap.c pcm_symbols.c
 
diff --git a/src/pcm/Makefile.in b/src/pcm/Makefile.in
index 363a466..d2b969f 100644
--- a/src/pcm/Makefile.in
+++ b/src/pcm/Makefile.in
@@ -132,15 +132,15 @@ CONFIG_HEADER = $(top_builddir)/include/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 libpcm_la_LIBADD =
-am__libpcm_la_SOURCES_DIST = mask.c interval.c pcm.c pcm_params.c \
-	pcm_simple.c pcm_hw.c pcm_misc.c pcm_mmap.c pcm_symbols.c \
-	pcm_generic.c pcm_plugin.c pcm_copy.c pcm_linear.c pcm_route.c \
-	pcm_mulaw.c pcm_alaw.c pcm_adpcm.c pcm_rate.c \
-	pcm_rate_linear.c pcm_plug.c pcm_multi.c pcm_shm.c pcm_file.c \
-	pcm_null.c pcm_empty.c pcm_share.c pcm_meter.c pcm_hooks.c \
-	pcm_lfloat.c pcm_ladspa.c pcm_dmix.c pcm_dshare.c pcm_dsnoop.c \
-	pcm_direct.c pcm_asym.c pcm_iec958.c pcm_softvol.c \
-	pcm_extplug.c pcm_ioplug.c pcm_mmap_emul.c
+am__libpcm_la_SOURCES_DIST = mask.c interval.c pcm_tinyalsa.c pcm.c \
+	pcm_params.c pcm_simple.c pcm_hw.c pcm_misc.c pcm_mmap.c \
+	pcm_symbols.c pcm_generic.c pcm_plugin.c pcm_copy.c \
+	pcm_linear.c pcm_route.c pcm_mulaw.c pcm_alaw.c pcm_adpcm.c \
+	pcm_rate.c pcm_rate_linear.c pcm_plug.c pcm_multi.c pcm_shm.c \
+	pcm_file.c pcm_null.c pcm_empty.c pcm_share.c pcm_meter.c \
+	pcm_hooks.c pcm_lfloat.c pcm_ladspa.c pcm_dmix.c pcm_dshare.c \
+	pcm_dsnoop.c pcm_direct.c pcm_asym.c pcm_iec958.c \
+	pcm_softvol.c pcm_extplug.c pcm_ioplug.c pcm_mmap_emul.c
 @BUILD_PCM_PLUGIN_TRUE@am__objects_1 = pcm_generic.lo pcm_plugin.lo
 @BUILD_PCM_PLUGIN_COPY_TRUE@am__objects_2 = pcm_copy.lo
 @BUILD_PCM_PLUGIN_LINEAR_TRUE@am__objects_3 = pcm_linear.lo
@@ -173,19 +173,19 @@ am__libpcm_la_SOURCES_DIST = mask.c interval.c pcm.c pcm_params.c \
 @BUILD_PCM_PLUGIN_EXTPLUG_TRUE@am__objects_29 = pcm_extplug.lo
 @BUILD_PCM_PLUGIN_IOPLUG_TRUE@am__objects_30 = pcm_ioplug.lo
 @BUILD_PCM_PLUGIN_MMAP_EMUL_TRUE@am__objects_31 = pcm_mmap_emul.lo
-am_libpcm_la_OBJECTS = mask.lo interval.lo pcm.lo pcm_params.lo \
-	pcm_simple.lo pcm_hw.lo pcm_misc.lo pcm_mmap.lo pcm_symbols.lo \
-	$(am__objects_1) $(am__objects_2) $(am__objects_3) \
-	$(am__objects_4) $(am__objects_5) $(am__objects_6) \
-	$(am__objects_7) $(am__objects_8) $(am__objects_9) \
-	$(am__objects_10) $(am__objects_11) $(am__objects_12) \
-	$(am__objects_13) $(am__objects_14) $(am__objects_15) \
-	$(am__objects_16) $(am__objects_17) $(am__objects_18) \
-	$(am__objects_19) $(am__objects_20) $(am__objects_21) \
-	$(am__objects_22) $(am__objects_23) $(am__objects_24) \
-	$(am__objects_25) $(am__objects_26) $(am__objects_27) \
-	$(am__objects_28) $(am__objects_29) $(am__objects_30) \
-	$(am__objects_31)
+am_libpcm_la_OBJECTS = mask.lo interval.lo pcm_tinyalsa.lo pcm.lo \
+	pcm_params.lo pcm_simple.lo pcm_hw.lo pcm_misc.lo pcm_mmap.lo \
+	pcm_symbols.lo $(am__objects_1) $(am__objects_2) \
+	$(am__objects_3) $(am__objects_4) $(am__objects_5) \
+	$(am__objects_6) $(am__objects_7) $(am__objects_8) \
+	$(am__objects_9) $(am__objects_10) $(am__objects_11) \
+	$(am__objects_12) $(am__objects_13) $(am__objects_14) \
+	$(am__objects_15) $(am__objects_16) $(am__objects_17) \
+	$(am__objects_18) $(am__objects_19) $(am__objects_20) \
+	$(am__objects_21) $(am__objects_22) $(am__objects_23) \
+	$(am__objects_24) $(am__objects_25) $(am__objects_26) \
+	$(am__objects_27) $(am__objects_28) $(am__objects_29) \
+	$(am__objects_30) $(am__objects_31)
 libpcm_la_OBJECTS = $(am_libpcm_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -428,18 +428,19 @@ top_srcdir = @top_srcdir@
 SUBDIRS = 
 DIST_SUBDIRS = scopes
 EXTRA_LTLIBRARIES = libpcm.la
-libpcm_la_SOURCES = mask.c interval.c pcm.c pcm_params.c pcm_simple.c \
-	pcm_hw.c pcm_misc.c pcm_mmap.c pcm_symbols.c $(am__append_1) \
-	$(am__append_2) $(am__append_3) $(am__append_4) \
-	$(am__append_5) $(am__append_6) $(am__append_7) \
-	$(am__append_8) $(am__append_9) $(am__append_10) \
-	$(am__append_11) $(am__append_12) $(am__append_13) \
-	$(am__append_14) $(am__append_15) $(am__append_16) \
-	$(am__append_17) $(am__append_18) $(am__append_19) \
-	$(am__append_20) $(am__append_21) $(am__append_22) \
-	$(am__append_23) $(am__append_24) $(am__append_25) \
-	$(am__append_26) $(am__append_27) $(am__append_28) \
-	$(am__append_29) $(am__append_30) $(am__append_31)
+libpcm_la_SOURCES = mask.c interval.c pcm_tinyalsa.c pcm.c \
+	pcm_params.c pcm_simple.c pcm_hw.c pcm_misc.c pcm_mmap.c \
+	pcm_symbols.c $(am__append_1) $(am__append_2) $(am__append_3) \
+	$(am__append_4) $(am__append_5) $(am__append_6) \
+	$(am__append_7) $(am__append_8) $(am__append_9) \
+	$(am__append_10) $(am__append_11) $(am__append_12) \
+	$(am__append_13) $(am__append_14) $(am__append_15) \
+	$(am__append_16) $(am__append_17) $(am__append_18) \
+	$(am__append_19) $(am__append_20) $(am__append_21) \
+	$(am__append_22) $(am__append_23) $(am__append_24) \
+	$(am__append_25) $(am__append_26) $(am__append_27) \
+	$(am__append_28) $(am__append_29) $(am__append_30) \
+	$(am__append_31)
 EXTRA_DIST = pcm_dmix_i386.c pcm_dmix_x86_64.c pcm_dmix_generic.c
 noinst_HEADERS = pcm_local.h pcm_plugin.h mask.h mask_inline.h \
 	         interval.h interval_inline.h plugin_ops.h ladspa.h \
@@ -531,6 +532,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcm_simple.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcm_softvol.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcm_symbols.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcm_tinyalsa.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff --git a/src/pcm/pcm_hw.c b/src/pcm/pcm_hw.c
index 59a2420..4d3492f 100644
--- a/src/pcm/pcm_hw.c
+++ b/src/pcm/pcm_hw.c
@@ -40,6 +40,7 @@
 #include "pcm_local.h"
 #include "../control/control_local.h"
 #include "../timer/timer_local.h"
+#include <tinyalsa/asoundlib.h>
 
 //#define DEBUG_RW		/* use to debug readi/writei/readn/writen */
 //#define DEBUG_MMAP		/* debug mmap_commit */
@@ -90,6 +91,7 @@ static const snd_pcm_fast_ops_t snd_pcm_hw_fast_ops_timer;
 typedef struct {
 	int version;
 	int fd;
+	struct pcm *ext_pcm;
 	int card, device, subdevice;
 
 	volatile struct snd_pcm_mmap_status * mmap_status;
@@ -1076,6 +1078,16 @@ static int snd_pcm_hw_munmap(snd_pcm_t *pcm ATTRIBUTE_UNUSED)
 	return 0;
 }
 
+static int snd_pcm_ahub_close(struct pcm *pcm)
+{
+	if (pcm == NULL) {
+		return 0;
+	}
+	pcm_close(pcm);
+
+	return 0;
+}
+
 static int snd_pcm_hw_close(snd_pcm_t *pcm)
 {
 	snd_pcm_hw_t *hw = pcm->private_data;
@@ -1085,6 +1097,9 @@ static int snd_pcm_hw_close(snd_pcm_t *pcm)
 		SYSMSG("close failed (%i)\n", err);
 	}
 
+	snd_pcm_ahub_close(hw->ext_pcm);
+	hw->ext_pcm = NULL;
+
 	unmap_status_and_control_data(hw);
 
 	free(hw);
@@ -1730,6 +1745,64 @@ int snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 	return ret;
 }
 
+static struct pcm * snd_pcm_ahub_open(int card, int device, int channels,
+                 unsigned int rate, snd_pcm_format_t format, unsigned int period_size,
+                 unsigned int period_count, snd_pcm_stream_t stream, int mode)
+{
+	struct pcm_config config;
+    struct pcm *pcm;
+	int fmode = 0;
+
+	if (card < 0) {
+		return NULL;
+	}
+
+	memset(&config, 0, sizeof(config));
+	config.channels = channels;
+	config.rate = rate;
+	config.period_size = period_size;
+	config.period_count = period_count;
+
+	switch (format) {
+	case SND_PCM_FORMAT_S16:
+		config.format = PCM_FORMAT_S16_LE;
+		break;
+	case SND_PCM_FORMAT_S24:
+		config.format = PCM_FORMAT_S24_3LE;
+		break;
+	case SND_PCM_FORMAT_S32:
+		config.format = PCM_FORMAT_S32_LE;
+		break;
+	default:
+		config.format = PCM_FORMAT_S16_LE;
+		/*SNDERR("Unable to support format:%s, %d, default:%s, %d",
+			(format >= 0)?snd_pcm_format_name(format):"SND_PCM_FORMAT_UNKNOWN", format,
+			snd_pcm_format_name(SND_PCM_FORMAT_S16), config.format);*/
+		break;
+	}
+	config.start_threshold = 0;
+	config.stop_threshold = 0;
+	config.silence_threshold = 0;
+
+	fmode = O_RDWR;
+	if (mode & SND_PCM_NONBLOCK)
+		fmode |= O_NONBLOCK;
+	if (mode & SND_PCM_ASYNC)
+		fmode |= O_ASYNC;
+	if (mode & SND_PCM_APPEND)
+		fmode |= O_APPEND;
+
+	pcm = pcm_fmode_open(card, device, (stream == SND_PCM_STREAM_PLAYBACK)?PCM_OUT:PCM_IN,
+				&config, fmode);
+	if (!pcm || !pcm_is_ready(pcm)) {
+		SNDERR("Unable to open PCM device hw:%u,%u (%s)", card, device, pcm_get_error(pcm));
+		return NULL;
+	}
+	pcm_prepare(pcm);
+
+	return pcm;
+}
+
 /*! \page pcm_plugins
 
 \section pcm_plugins_hw Plugin: hw
@@ -1748,7 +1821,9 @@ older ALSA stuff, turn this option off.
 pcm.name {
 	type hw			# Kernel PCM
 	card INT/STR		# Card name (string) or number (integer)
-	[device INT]		# Device number (default 0)
+	[ext_card INT]		# Card number (integer, default -1)
+	[device INT]			# Device number (default 0)
+	[ext_device INT]		# Device number (default 0)
 	[subdevice INT]		# Subdevice number (default -1: first available)
 	[sync_ptr_ioctl BOOL]	# Use SYNC_PTR ioctl rather than the direct mmap access for control structures
 	[nonblock BOOL]		# Force non-blocking open mode
@@ -1785,11 +1860,13 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 		     snd_pcm_stream_t stream, int mode)
 {
 	snd_config_iterator_t i, next;
-	long card = -1, device = 0, subdevice = -1;
+	long card = -1, device = 0, ext_card = -1, ext_device = 0, subdevice = -1;
+	struct pcm *ext_pcm = NULL;
 	const char *str;
 	int err, sync_ptr_ioctl = 0;
-	int rate = 0, channels = 0;
+	int rate = 0, ext_rate = 44100, channels = 0, ext_channels = 2;
 	snd_pcm_format_t format = SND_PCM_FORMAT_UNKNOWN;
+	snd_pcm_format_t ext_format = SND_PCM_FORMAT_S16_LE;
 	snd_config_t *n;
 	int nonblock = 1; /* non-block per default */
 	snd_pcm_chmap_query_t **chmap = NULL;
@@ -1826,14 +1903,31 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 			}
 			continue;
 		}
+		if (strcmp(id, "ext_card") == 0) {
+			err = snd_config_get_integer(n, &ext_card);
+			if (err < 0) {
+				SNDERR("Invalid value for %s", id);
+				goto fail;
+			}
+			continue;
+		}
 		if (strcmp(id, "device") == 0) {
 			err = snd_config_get_integer(n, &device);
 			if (err < 0) {
-				SNDERR("Invalid type for %s", id);
+				SNDERR("Invalid value for %s", id);
+				goto fail;
+			}
+			continue;
+		}
+		if (strcmp(id, "ext_device") == 0) {
+			err = snd_config_get_integer(n, &ext_device);
+			if (err < 0) {
+				SNDERR("Invalid value for %s", id);
 				goto fail;
 			}
 			continue;
 		}
+
 		if (strcmp(id, "subdevice") == 0) {
 			err = snd_config_get_integer(n, &subdevice);
 			if (err < 0) {
@@ -1866,6 +1960,16 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 			rate = val;
 			continue;
 		}
+		if (strcmp(id, "ext_rate") == 0) {
+			long val;
+			err = snd_config_get_integer(n, &val);
+			if (err < 0) {
+				SNDERR("Invalid type for %s", id);
+				goto fail;
+			}
+			ext_rate = val;
+			continue;
+		}
 		if (strcmp(id, "format") == 0) {
 			err = snd_config_get_string(n, &str);
 			if (err < 0) {
@@ -1875,6 +1979,15 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 			format = snd_pcm_format_value(str);
 			continue;
 		}
+		if (strcmp(id, "ext_format") == 0) {
+			err = snd_config_get_string(n, &str);
+			if (err < 0) {
+				SNDERR("invalid type for %s", id);
+				goto fail;
+			}
+			ext_format = snd_pcm_format_value(str);
+			continue;
+		}
 		if (strcmp(id, "channels") == 0) {
 			long val;
 			err = snd_config_get_integer(n, &val);
@@ -1885,6 +1998,16 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 			channels = val;
 			continue;
 		}
+		if (strcmp(id, "ext_channels") == 0) {
+			long val;
+			err = snd_config_get_integer(n, &val);
+			if (err < 0) {
+				SNDERR("Invalid type for %s", id);
+				goto fail;
+			}
+			ext_channels = val;
+			continue;
+		}
 		if (strcmp(id, "chmap") == 0) {
 			snd_pcm_free_chmaps(chmap);
 			chmap = _snd_pcm_parse_config_chmaps(n);
@@ -1904,6 +2027,11 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 		err = -EINVAL;
 		goto fail;
 	}
+
+	ext_pcm = snd_pcm_ahub_open(ext_card, ext_device,
+				ext_channels, ext_rate, ext_format, 1024, 8,
+				stream, mode | (nonblock ? SND_PCM_NONBLOCK : 0));
+
 	err = snd_pcm_hw_open(pcmp, name, card, device, subdevice, stream,
 			      mode | (nonblock ? SND_PCM_NONBLOCK : 0),
 			      0, sync_ptr_ioctl);
@@ -1930,6 +2058,7 @@ int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,
 		hw->rate = rate;
 	if (chmap)
 		hw->chmap_override = chmap;
+	hw->ext_pcm = ext_pcm;
 
 	return 0;
 
diff --git a/src/pcm/pcm_tinyalsa.c b/src/pcm/pcm_tinyalsa.c
new file mode 100644
index 0000000..0e33140
--- /dev/null
+++ b/src/pcm/pcm_tinyalsa.c
@@ -0,0 +1,1519 @@
+/* pcm.c
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <poll.h>
+
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <limits.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include <sound/asound.h>
+
+#include "tinyalsa/asoundlib.h"
+
+#define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
+
+/* Logs information into a string; follows snprintf() in that
+ * offset may be greater than size, and though no characters are copied
+ * into string, characters are still counted into offset. */
+#define STRLOG(string, offset, size, ...) \
+    do { int temp, clipoffset = offset > size ? size : offset; \
+         temp = snprintf(string + clipoffset, size - clipoffset, __VA_ARGS__); \
+         if (temp > 0) offset += temp; } while (0)
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+#endif
+
+/* refer to SNDRV_PCM_ACCESS_##index in sound/asound.h. */
+static const char * const access_lookup[] = {
+        "MMAP_INTERLEAVED",
+        "MMAP_NONINTERLEAVED",
+        "MMAP_COMPLEX",
+        "RW_INTERLEAVED",
+        "RW_NONINTERLEAVED",
+};
+
+/* refer to SNDRV_PCM_FORMAT_##index in sound/asound.h. */
+static const char * const format_lookup[] = {
+        /*[0] =*/ "S8",
+        "U8",
+        "S16_LE",
+        "S16_BE",
+        "U16_LE",
+        "U16_BE",
+        "S24_LE",
+        "S24_BE",
+        "U24_LE",
+        "U24_BE",
+        "S32_LE",
+        "S32_BE",
+        "U32_LE",
+        "U32_BE",
+        "FLOAT_LE",
+        "FLOAT_BE",
+        "FLOAT64_LE",
+        "FLOAT64_BE",
+        "IEC958_SUBFRAME_LE",
+        "IEC958_SUBFRAME_BE",
+        "MU_LAW",
+        "A_LAW",
+        "IMA_ADPCM",
+        "MPEG",
+        /*[24] =*/ "GSM",
+        /* gap */
+        [31] = "SPECIAL",
+        "S24_3LE",
+        "S24_3BE",
+        "U24_3LE",
+        "U24_3BE",
+        "S20_3LE",
+        "S20_3BE",
+        "U20_3LE",
+        "U20_3BE",
+        "S18_3LE",
+        "S18_3BE",
+        "U18_3LE",
+        /*[43] =*/ "U18_3BE",
+#if 0
+        /* recent additions, may not be present on local asound.h */
+        "G723_24",
+        "G723_24_1B",
+        "G723_40",
+        "G723_40_1B",
+        "DSD_U8",
+        "DSD_U16_LE",
+#endif
+};
+
+/* refer to SNDRV_PCM_SUBFORMAT_##index in sound/asound.h. */
+static const char * const subformat_lookup[] = {
+        "STD",
+};
+
+static inline int param_is_mask(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
+}
+
+static inline int param_is_interval(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
+}
+
+static inline struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+}
+
+static inline struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
+}
+
+static void param_set_mask(struct snd_pcm_hw_params *p, int n, unsigned int bit)
+{
+    if (bit >= SNDRV_MASK_MAX)
+        return;
+    if (param_is_mask(n)) {
+        struct snd_mask *m = param_to_mask(p, n);
+        m->bits[0] = 0;
+        m->bits[1] = 0;
+        m->bits[bit >> 5] |= (1 << (bit & 31));
+    }
+}
+
+static void param_set_min(struct snd_pcm_hw_params *p, int n, unsigned int val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+    }
+}
+
+static unsigned int param_get_min(struct snd_pcm_hw_params *p, int n)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        return i->min;
+    }
+    return 0;
+}
+
+static void param_set_max(struct snd_pcm_hw_params *p, int n, unsigned int val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->max = val;
+    }
+}
+
+static unsigned int param_get_max(struct snd_pcm_hw_params *p, int n)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        return i->max;
+    }
+    return 0;
+}
+
+static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned int val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+        i->max = val;
+        i->integer = 1;
+    }
+}
+
+static unsigned int param_get_int(struct snd_pcm_hw_params *p, int n)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        if (i->integer)
+            return i->max;
+    }
+    return 0;
+}
+
+static void param_init(struct snd_pcm_hw_params *p)
+{
+    int n;
+
+    memset(p, 0, sizeof(*p));
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+            m->bits[0] = ~0;
+            m->bits[1] = ~0;
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+            i->min = 0;
+            i->max = ~0;
+    }
+    p->rmask = ~0U;
+    p->cmask = 0;
+    p->info = ~0U;
+}
+
+#define PCM_ERROR_MAX 128
+
+struct pcm {
+    int fd;
+    unsigned int flags;
+    int running:1;
+    int prepared:1;
+    int underruns;
+    unsigned int buffer_size;
+    unsigned int boundary;
+    char error[PCM_ERROR_MAX];
+    struct pcm_config config;
+    struct snd_pcm_mmap_status *mmap_status;
+    struct snd_pcm_mmap_control *mmap_control;
+    struct snd_pcm_sync_ptr *sync_ptr;
+    void *mmap_buffer;
+    unsigned int noirq_frames_per_msec;
+    int wait_for_avail_min;
+    unsigned int subdevice;
+};
+
+unsigned int pcm_get_buffer_size(struct pcm *pcm)
+{
+    return pcm->buffer_size;
+}
+
+const char* pcm_get_error(struct pcm *pcm)
+{
+    return pcm->error;
+}
+
+unsigned int pcm_get_subdevice(struct pcm *pcm)
+{
+    return pcm->subdevice;
+}
+
+static int oops(struct pcm *pcm, int e, const char *fmt, ...)
+{
+    va_list ap;
+    int sz;
+
+    va_start(ap, fmt);
+    vsnprintf(pcm->error, PCM_ERROR_MAX, fmt, ap);
+    va_end(ap);
+    sz = strlen(pcm->error);
+
+    if (e)
+        snprintf(pcm->error + sz, PCM_ERROR_MAX - sz,
+                 ": %s", strerror(e));
+    return -1;
+}
+
+static unsigned int pcm_format_to_alsa(enum pcm_format format)
+{
+    switch (format) {
+    case PCM_FORMAT_S32_LE:
+        return SNDRV_PCM_FORMAT_S32_LE;
+    case PCM_FORMAT_S8:
+        return SNDRV_PCM_FORMAT_S8;
+    case PCM_FORMAT_S24_3LE:
+        return SNDRV_PCM_FORMAT_S24_3LE;
+    case PCM_FORMAT_S24_LE:
+        return SNDRV_PCM_FORMAT_S24_LE;
+    default:
+    case PCM_FORMAT_S16_LE:
+        return SNDRV_PCM_FORMAT_S16_LE;
+    };
+}
+
+unsigned int pcm_format_to_bits(enum pcm_format format)
+{
+    switch (format) {
+    case PCM_FORMAT_S32_LE:
+    case PCM_FORMAT_S24_LE:
+        return 32;
+    case PCM_FORMAT_S24_3LE:
+        return 24;
+    default:
+    case PCM_FORMAT_S16_LE:
+        return 16;
+    };
+}
+
+unsigned int pcm_bytes_to_frames(struct pcm *pcm, unsigned int bytes)
+{
+    return bytes / (pcm->config.channels *
+        (pcm_format_to_bits(pcm->config.format) >> 3));
+}
+
+unsigned int pcm_frames_to_bytes(struct pcm *pcm, unsigned int frames)
+{
+    return frames * pcm->config.channels *
+        (pcm_format_to_bits(pcm->config.format) >> 3);
+}
+
+static int pcm_sync_ptr(struct pcm *pcm, int flags) {
+    if (pcm->sync_ptr) {
+        pcm->sync_ptr->flags = flags;
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SYNC_PTR, pcm->sync_ptr) < 0)
+            return -1;
+    }
+    return 0;
+}
+
+static int pcm_hw_mmap_status(struct pcm *pcm) {
+
+    if (pcm->sync_ptr)
+        return 0;
+
+    int page_size = sysconf(_SC_PAGE_SIZE);
+    pcm->mmap_status = mmap(NULL, page_size, PROT_READ, MAP_FILE | MAP_SHARED,
+                            pcm->fd, SNDRV_PCM_MMAP_OFFSET_STATUS);
+    if (pcm->mmap_status == MAP_FAILED)
+        pcm->mmap_status = NULL;
+    if (!pcm->mmap_status)
+        goto mmap_error;
+
+    pcm->mmap_control = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
+                             MAP_FILE | MAP_SHARED, pcm->fd, SNDRV_PCM_MMAP_OFFSET_CONTROL);
+    if (pcm->mmap_control == MAP_FAILED)
+        pcm->mmap_control = NULL;
+    if (!pcm->mmap_control) {
+        munmap(pcm->mmap_status, page_size);
+        pcm->mmap_status = NULL;
+        goto mmap_error;
+    }
+    if (pcm->flags & PCM_MMAP)
+        pcm->mmap_control->avail_min = pcm->config.avail_min;
+    else
+        pcm->mmap_control->avail_min = 1;
+
+    return 0;
+
+mmap_error:
+
+    pcm->sync_ptr = calloc(1, sizeof(*pcm->sync_ptr));
+    if (!pcm->sync_ptr)
+        return -ENOMEM;
+    pcm->mmap_status = &pcm->sync_ptr->s.status;
+    pcm->mmap_control = &pcm->sync_ptr->c.control;
+    if (pcm->flags & PCM_MMAP)
+        pcm->mmap_control->avail_min = pcm->config.avail_min;
+    else
+        pcm->mmap_control->avail_min = 1;
+
+    pcm_sync_ptr(pcm, 0);
+
+    return 0;
+}
+
+static void pcm_hw_munmap_status(struct pcm *pcm) {
+    if (pcm->sync_ptr) {
+        free(pcm->sync_ptr);
+        pcm->sync_ptr = NULL;
+    } else {
+        int page_size = sysconf(_SC_PAGE_SIZE);
+        if (pcm->mmap_status)
+            munmap(pcm->mmap_status, page_size);
+        if (pcm->mmap_control)
+            munmap(pcm->mmap_control, page_size);
+    }
+    pcm->mmap_status = NULL;
+    pcm->mmap_control = NULL;
+}
+
+static int pcm_areas_copy(struct pcm *pcm, unsigned int pcm_offset,
+                          char *buf, unsigned int src_offset,
+                          unsigned int frames)
+{
+    int size_bytes = pcm_frames_to_bytes(pcm, frames);
+    int pcm_offset_bytes = pcm_frames_to_bytes(pcm, pcm_offset);
+    int src_offset_bytes = pcm_frames_to_bytes(pcm, src_offset);
+
+    /* interleaved only atm */
+    if (pcm->flags & PCM_IN)
+        memcpy(buf + src_offset_bytes,
+               (char*)pcm->mmap_buffer + pcm_offset_bytes,
+               size_bytes);
+    else
+        memcpy((char*)pcm->mmap_buffer + pcm_offset_bytes,
+               buf + src_offset_bytes,
+               size_bytes);
+    return 0;
+}
+
+static int pcm_mmap_transfer_areas(struct pcm *pcm, char *buf,
+                                unsigned int offset, unsigned int size)
+{
+    void *pcm_areas;
+    int commit;
+    unsigned int pcm_offset, frames, count = 0;
+
+    while (size > 0) {
+        frames = size;
+        pcm_mmap_begin(pcm, &pcm_areas, &pcm_offset, &frames);
+        pcm_areas_copy(pcm, pcm_offset, buf, offset, frames);
+        commit = pcm_mmap_commit(pcm, pcm_offset, frames);
+        if (commit < 0) {
+            oops(pcm, errno, "failed to commit %d frames\n", frames);
+            return commit;
+        }
+
+        offset += commit;
+        count += commit;
+        size -= commit;
+    }
+    return count;
+}
+
+int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
+                       struct timespec *tstamp)
+{
+    int frames;
+    int rc;
+    snd_pcm_uframes_t hw_ptr;
+
+    if (!pcm_is_ready(pcm))
+        return -1;
+
+    rc = pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_APPL|SNDRV_PCM_SYNC_PTR_HWSYNC);
+    if (rc < 0)
+        return -1;
+
+    if ((pcm->mmap_status->state != PCM_STATE_RUNNING) &&
+            (pcm->mmap_status->state != PCM_STATE_DRAINING))
+        return -1;
+
+    *tstamp = pcm->mmap_status->tstamp;
+    if (tstamp->tv_sec == 0 && tstamp->tv_nsec == 0)
+        return -1;
+
+    hw_ptr = pcm->mmap_status->hw_ptr;
+    if (pcm->flags & PCM_IN)
+        frames = hw_ptr - pcm->mmap_control->appl_ptr;
+    else
+        frames = hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
+
+    if (frames < 0)
+        frames += pcm->boundary;
+    else if (frames > (int)pcm->boundary)
+        frames -= pcm->boundary;
+
+    *avail = (unsigned int)frames;
+
+    return 0;
+}
+
+int pcm_mmap_get_hw_ptr(struct pcm* pcm, unsigned int *hw_ptr, struct timespec *tstamp)
+{
+    int frames;
+    int rc;
+
+    if (pcm == NULL || hw_ptr == NULL || tstamp == NULL)
+        return oops(pcm, EINVAL, "pcm %p, hw_ptr %p, tstamp %p", pcm, hw_ptr, tstamp);
+
+    if (!pcm_is_ready(pcm))
+        return oops(pcm, errno, "pcm_is_ready failed");
+
+    rc = pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
+    if (rc < 0)
+        return oops(pcm, errno, "pcm_sync_ptr failed");
+
+    if (pcm->mmap_status == NULL)
+        return oops(pcm, EINVAL, "pcm %p, mmap_status is NULL", pcm);
+
+    if ((pcm->mmap_status->state != PCM_STATE_RUNNING) &&
+            (pcm->mmap_status->state != PCM_STATE_DRAINING))
+        return oops(pcm, ENOSYS, "invalid stream state %d", pcm->mmap_status->state);
+
+    *tstamp = pcm->mmap_status->tstamp;
+    if (tstamp->tv_sec == 0 && tstamp->tv_nsec == 0)
+        return oops(pcm, errno, "invalid time stamp");
+
+    *hw_ptr = pcm->mmap_status->hw_ptr;
+
+    return 0;
+}
+
+int pcm_write(struct pcm *pcm, const void *data, unsigned int count)
+{
+    struct snd_xferi x;
+
+    if (pcm->flags & PCM_IN)
+        return -EINVAL;
+
+    x.buf = (void*)data;
+    x.frames = count / (pcm->config.channels *
+                        pcm_format_to_bits(pcm->config.format) / 8);
+
+    for (;;) {
+        if (!pcm->running) {
+            int prepare_error = pcm_prepare(pcm);
+            if (prepare_error)
+                return prepare_error;
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
+                return oops(pcm, errno, "cannot write initial data");
+            pcm->running = 1;
+            return 0;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x)) {
+            pcm->prepared = 0;
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                /* we failed to make our window -- try to restart if we are
+                 * allowed to do so.  Otherwise, simply allow the EPIPE error to
+                 * propagate up to the app level */
+                pcm->underruns++;
+                if (pcm->flags & PCM_NORESTART)
+                    return -EPIPE;
+                continue;
+            }
+            return oops(pcm, errno, "cannot write stream data");
+        }
+        return 0;
+    }
+}
+
+int pcm_read(struct pcm *pcm, void *data, unsigned int count)
+{
+    struct snd_xferi x;
+
+    if (!(pcm->flags & PCM_IN))
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = count / (pcm->config.channels *
+                        pcm_format_to_bits(pcm->config.format) / 8);
+
+    for (;;) {
+        if (!pcm->running) {
+            if (pcm_start(pcm) < 0) {
+                fprintf(stderr, "start error");
+                return -errno;
+            }
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x)) {
+            pcm->prepared = 0;
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                    /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot read stream data");
+        }
+        return 0;
+    }
+}
+
+static struct pcm bad_pcm = {
+    .fd = -1,
+};
+
+struct pcm_params *pcm_params_get(unsigned int card, unsigned int device,
+                                  unsigned int flags)
+{
+    struct snd_pcm_hw_params *params;
+    char fn[256];
+    int fd;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+    fd = open(fn, O_RDWR);
+    if (fd < 0) {
+        fprintf(stderr, "cannot open device '%s'\n", fn);
+        goto err_open;
+    }
+
+    params = calloc(1, sizeof(struct snd_pcm_hw_params));
+    if (!params)
+        goto err_calloc;
+
+    param_init(params);
+    if (ioctl(fd, SNDRV_PCM_IOCTL_HW_REFINE, params)) {
+        fprintf(stderr, "SNDRV_PCM_IOCTL_HW_REFINE error (%d)\n", errno);
+        goto err_hw_refine;
+    }
+
+    close(fd);
+
+    return (struct pcm_params *)params;
+
+err_hw_refine:
+    free(params);
+err_calloc:
+    close(fd);
+err_open:
+    return NULL;
+}
+
+void pcm_params_free(struct pcm_params *pcm_params)
+{
+    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+
+    if (params)
+        free(params);
+}
+
+static int pcm_param_to_alsa(enum pcm_param param)
+{
+    switch (param) {
+    case PCM_PARAM_ACCESS:
+        return SNDRV_PCM_HW_PARAM_ACCESS;
+    case PCM_PARAM_FORMAT:
+        return SNDRV_PCM_HW_PARAM_FORMAT;
+    case PCM_PARAM_SUBFORMAT:
+        return SNDRV_PCM_HW_PARAM_SUBFORMAT;
+    case PCM_PARAM_SAMPLE_BITS:
+        return SNDRV_PCM_HW_PARAM_SAMPLE_BITS;
+        break;
+    case PCM_PARAM_FRAME_BITS:
+        return SNDRV_PCM_HW_PARAM_FRAME_BITS;
+        break;
+    case PCM_PARAM_CHANNELS:
+        return SNDRV_PCM_HW_PARAM_CHANNELS;
+        break;
+    case PCM_PARAM_RATE:
+        return SNDRV_PCM_HW_PARAM_RATE;
+        break;
+    case PCM_PARAM_PERIOD_TIME:
+        return SNDRV_PCM_HW_PARAM_PERIOD_TIME;
+        break;
+    case PCM_PARAM_PERIOD_SIZE:
+        return SNDRV_PCM_HW_PARAM_PERIOD_SIZE;
+        break;
+    case PCM_PARAM_PERIOD_BYTES:
+        return SNDRV_PCM_HW_PARAM_PERIOD_BYTES;
+        break;
+    case PCM_PARAM_PERIODS:
+        return SNDRV_PCM_HW_PARAM_PERIODS;
+        break;
+    case PCM_PARAM_BUFFER_TIME:
+        return SNDRV_PCM_HW_PARAM_BUFFER_TIME;
+        break;
+    case PCM_PARAM_BUFFER_SIZE:
+        return SNDRV_PCM_HW_PARAM_BUFFER_SIZE;
+        break;
+    case PCM_PARAM_BUFFER_BYTES:
+        return SNDRV_PCM_HW_PARAM_BUFFER_BYTES;
+        break;
+    case PCM_PARAM_TICK_TIME:
+        return SNDRV_PCM_HW_PARAM_TICK_TIME;
+        break;
+
+    default:
+        return -1;
+    }
+}
+
+struct pcm_mask *pcm_params_get_mask(struct pcm_params *pcm_params,
+                                     enum pcm_param param)
+{
+    int p;
+    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+    if (params == NULL) {
+        return NULL;
+    }
+
+    p = pcm_param_to_alsa(param);
+    if (p < 0 || !param_is_mask(p)) {
+        return NULL;
+    }
+
+    return (struct pcm_mask *)param_to_mask(params, p);
+}
+
+unsigned int pcm_params_get_min(struct pcm_params *pcm_params,
+                                enum pcm_param param)
+{
+    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+    int p;
+
+    if (!params)
+        return 0;
+
+    p = pcm_param_to_alsa(param);
+    if (p < 0)
+        return 0;
+
+    return param_get_min(params, p);
+}
+
+void pcm_params_set_min(struct pcm_params *pcm_params,
+                                enum pcm_param param, unsigned int val)
+{
+    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+    int p;
+
+    if (!params)
+        return;
+
+    p = pcm_param_to_alsa(param);
+    if (p < 0)
+        return;
+
+    param_set_min(params, p, val);
+}
+
+unsigned int pcm_params_get_max(struct pcm_params *pcm_params,
+                                enum pcm_param param)
+{
+    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+    int p;
+
+    if (!params)
+        return 0;
+
+    p = pcm_param_to_alsa(param);
+    if (p < 0)
+        return 0;
+
+    return param_get_max(params, p);
+}
+
+void pcm_params_set_max(struct pcm_params *pcm_params,
+                                enum pcm_param param, unsigned int val)
+{
+    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+    int p;
+
+    if (!params)
+        return;
+
+    p = pcm_param_to_alsa(param);
+    if (p < 0)
+        return;
+
+    param_set_max(params, p, val);
+}
+
+static int pcm_mask_test(struct pcm_mask *m, unsigned int index)
+{
+    const unsigned int bitshift = 5; /* for 32 bit integer */
+    const unsigned int bitmask = (1 << bitshift) - 1;
+    unsigned int element;
+
+    element = index >> bitshift;
+    if (element >= ARRAY_SIZE(m->bits))
+        return 0; /* for safety, but should never occur */
+    return (m->bits[element] >> (index & bitmask)) & 1;
+}
+
+static int pcm_mask_to_string(struct pcm_mask *m, char *string, unsigned int size,
+                              char *mask_name,
+                              const char * const *bit_array_name, size_t bit_array_size)
+{
+    unsigned int i;
+    unsigned int offset = 0;
+
+    if (m == NULL)
+        return 0;
+    if (bit_array_size < 32) {
+        STRLOG(string, offset, size, "%12s:\t%#08x\n", mask_name, m->bits[0]);
+    } else { /* spans two or more bitfields, print with an array index */
+        for (i = 0; i < (bit_array_size + 31) >> 5; ++i) {
+            STRLOG(string, offset, size, "%9s[%d]:\t%#08x\n",
+                   mask_name, i, m->bits[i]);
+        }
+    }
+    for (i = 0; i < bit_array_size; ++i) {
+        if (pcm_mask_test(m, i)) {
+            STRLOG(string, offset, size, "%12s \t%s\n", "", bit_array_name[i]);
+        }
+    }
+    return offset;
+}
+
+int pcm_params_to_string(struct pcm_params *params, char *string, unsigned int size)
+{
+    struct pcm_mask *m;
+    unsigned int min, max;
+    unsigned int clipoffset, offset;
+
+    m = pcm_params_get_mask(params, PCM_PARAM_ACCESS);
+    offset = pcm_mask_to_string(m, string, size,
+                                 "Access", access_lookup, ARRAY_SIZE(access_lookup));
+    m = pcm_params_get_mask(params, PCM_PARAM_FORMAT);
+    clipoffset = offset > size ? size : offset;
+    offset += pcm_mask_to_string(m, string + clipoffset, size - clipoffset,
+                                 "Format", format_lookup, ARRAY_SIZE(format_lookup));
+    m = pcm_params_get_mask(params, PCM_PARAM_SUBFORMAT);
+    clipoffset = offset > size ? size : offset;
+    offset += pcm_mask_to_string(m, string + clipoffset, size - clipoffset,
+                                 "Subformat", subformat_lookup, ARRAY_SIZE(subformat_lookup));
+    min = pcm_params_get_min(params, PCM_PARAM_RATE);
+    max = pcm_params_get_max(params, PCM_PARAM_RATE);
+    STRLOG(string, offset, size, "        Rate:\tmin=%uHz\tmax=%uHz\n", min, max);
+    min = pcm_params_get_min(params, PCM_PARAM_CHANNELS);
+    max = pcm_params_get_max(params, PCM_PARAM_CHANNELS);
+    STRLOG(string, offset, size, "    Channels:\tmin=%u\t\tmax=%u\n", min, max);
+    min = pcm_params_get_min(params, PCM_PARAM_SAMPLE_BITS);
+    max = pcm_params_get_max(params, PCM_PARAM_SAMPLE_BITS);
+    STRLOG(string, offset, size, " Sample bits:\tmin=%u\t\tmax=%u\n", min, max);
+    min = pcm_params_get_min(params, PCM_PARAM_PERIOD_SIZE);
+    max = pcm_params_get_max(params, PCM_PARAM_PERIOD_SIZE);
+    STRLOG(string, offset, size, " Period size:\tmin=%u\t\tmax=%u\n", min, max);
+    min = pcm_params_get_min(params, PCM_PARAM_PERIODS);
+    max = pcm_params_get_max(params, PCM_PARAM_PERIODS);
+    STRLOG(string, offset, size, "Period count:\tmin=%u\t\tmax=%u\n", min, max);
+    return offset;
+}
+
+int pcm_params_format_test(struct pcm_params *params, enum pcm_format format)
+{
+    unsigned int alsa_format = pcm_format_to_alsa(format);
+
+    if (alsa_format == SNDRV_PCM_FORMAT_S16_LE && format != PCM_FORMAT_S16_LE)
+        return 0; /* caution: format not recognized is equivalent to S16_LE */
+    return pcm_mask_test(pcm_params_get_mask(params, PCM_PARAM_FORMAT), alsa_format);
+}
+
+int pcm_close(struct pcm *pcm)
+{
+    if (pcm == &bad_pcm)
+        return 0;
+
+    pcm_hw_munmap_status(pcm);
+
+    if (pcm->flags & PCM_MMAP) {
+        pcm_stop(pcm);
+        munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+    }
+
+    if (pcm->fd >= 0)
+        close(pcm->fd);
+    pcm->prepared = 0;
+    pcm->running = 0;
+    pcm->buffer_size = 0;
+    pcm->fd = -1;
+    free(pcm);
+    return 0;
+}
+
+struct pcm *pcm_fmode_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config, int fmode)
+{
+    struct pcm *pcm;
+    struct snd_pcm_info info;
+    struct snd_pcm_hw_params params;
+    struct snd_pcm_sw_params sparams;
+    char fn[256];
+    int rc;
+
+    if (!config) {
+        return &bad_pcm; /* TODO: could support default config here */
+    }
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm)
+        return &bad_pcm; /* TODO: could support default config here */
+
+    pcm->config = *config;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+    pcm->flags = flags;
+    pcm->fd = open(fn, fmode);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", fn);
+        return pcm;
+    }
+
+    if (fcntl(pcm->fd, F_SETFL, fcntl(pcm->fd, F_GETFL) &
+              ~O_NONBLOCK) < 0) {
+        oops(pcm, errno, "failed to reset blocking mode '%s'", fn);
+        goto fail_close;
+    }
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info)) {
+        oops(pcm, errno, "cannot get info");
+        goto fail_close;
+    }
+    pcm->subdevice = info.subdevice;
+
+    param_init(&params);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                   pcm_format_to_alsa(config->format));
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                   SNDRV_PCM_SUBFORMAT_STD);
+    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+                  pcm_format_to_bits(config->format));
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                  pcm_format_to_bits(config->format) * config->channels);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                  config->channels);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+
+    if (flags & PCM_NOIRQ) {
+        if (!(flags & PCM_MMAP)) {
+            oops(pcm, EINVAL, "noirq only currently supported with mmap().");
+            goto fail_close;
+        }
+
+        params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
+        pcm->noirq_frames_per_msec = config->rate / 1000;
+    }
+
+    if (flags & PCM_MMAP)
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+    else
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+        oops(pcm, errno, "cannot set hw params");
+        goto fail_close;
+    }
+
+    /* get our refined hw_params */
+    config->period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+    config->period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
+    pcm->buffer_size = config->period_count * config->period_size;
+
+    if (flags & PCM_MMAP) {
+        pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
+                                PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
+        if (pcm->mmap_buffer == MAP_FAILED) {
+            oops(pcm, errno, "failed to mmap buffer %d bytes\n",
+                 pcm_frames_to_bytes(pcm, pcm->buffer_size));
+            goto fail_close;
+        }
+    }
+
+    memset(&sparams, 0, sizeof(sparams));
+    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_ENABLE;
+    sparams.period_step = 1;
+
+    if (!config->start_threshold) {
+        if (pcm->flags & PCM_IN)
+            pcm->config.start_threshold = sparams.start_threshold = 1;
+        else
+            pcm->config.start_threshold = sparams.start_threshold =
+                config->period_count * config->period_size / 2;
+    } else
+        sparams.start_threshold = config->start_threshold;
+
+    /* pick a high stop threshold - todo: does this need further tuning */
+    if (!config->stop_threshold) {
+        if (pcm->flags & PCM_IN)
+            pcm->config.stop_threshold = sparams.stop_threshold =
+                config->period_count * config->period_size * 10;
+        else
+            pcm->config.stop_threshold = sparams.stop_threshold =
+                config->period_count * config->period_size;
+    }
+    else
+        sparams.stop_threshold = config->stop_threshold;
+
+    if (!pcm->config.avail_min) {
+        if (pcm->flags & PCM_MMAP)
+            pcm->config.avail_min = sparams.avail_min = pcm->config.period_size;
+        else
+            pcm->config.avail_min = sparams.avail_min = 1;
+    } else
+        sparams.avail_min = config->avail_min;
+
+    sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
+    sparams.silence_threshold = config->silence_threshold;
+    sparams.silence_size = config->silence_size;
+    pcm->boundary = sparams.boundary = pcm->buffer_size;
+
+    while (pcm->boundary * 2 <= INT_MAX - pcm->buffer_size)
+        pcm->boundary *= 2;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
+        oops(pcm, errno, "cannot set sw params");
+        goto fail;
+    }
+
+    rc = pcm_hw_mmap_status(pcm);
+    if (rc < 0) {
+        oops(pcm, errno, "mmap status failed");
+        goto fail;
+    }
+
+#ifdef SNDRV_PCM_IOCTL_TTSTAMP
+    if (pcm->flags & PCM_MONOTONIC) {
+        int arg = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC;
+        rc = ioctl(pcm->fd, SNDRV_PCM_IOCTL_TTSTAMP, &arg);
+        if (rc < 0) {
+            oops(pcm, errno, "cannot set timestamp type");
+            goto fail;
+        }
+    }
+#endif
+
+    pcm->underruns = 0;
+    return pcm;
+
+fail:
+    if (flags & PCM_MMAP)
+        munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+fail_close:
+    close(pcm->fd);
+    pcm->fd = -1;
+    return pcm;
+}
+
+struct pcm *pcm_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config)
+{
+    struct pcm *pcm;
+    struct snd_pcm_info info;
+    struct snd_pcm_hw_params params;
+    struct snd_pcm_sw_params sparams;
+    char fn[256];
+    int rc;
+
+    if (!config) {
+        return &bad_pcm; /* TODO: could support default config here */
+    }
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm)
+        return &bad_pcm; /* TODO: could support default config here */
+
+    pcm->config = *config;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+    pcm->flags = flags;
+    pcm->fd = open(fn, O_RDWR|O_NONBLOCK);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", fn);
+        return pcm;
+    }
+
+    if (fcntl(pcm->fd, F_SETFL, fcntl(pcm->fd, F_GETFL) &
+              ~O_NONBLOCK) < 0) {
+        oops(pcm, errno, "failed to reset blocking mode '%s'", fn);
+        goto fail_close;
+    }
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info)) {
+        oops(pcm, errno, "cannot get info");
+        goto fail_close;
+    }
+    pcm->subdevice = info.subdevice;
+
+    param_init(&params);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                   pcm_format_to_alsa(config->format));
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                   SNDRV_PCM_SUBFORMAT_STD);
+    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+                  pcm_format_to_bits(config->format));
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                  pcm_format_to_bits(config->format) * config->channels);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                  config->channels);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+
+    if (flags & PCM_NOIRQ) {
+        if (!(flags & PCM_MMAP)) {
+            oops(pcm, EINVAL, "noirq only currently supported with mmap().");
+            goto fail_close;
+        }
+
+        params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
+        pcm->noirq_frames_per_msec = config->rate / 1000;
+    }
+
+    if (flags & PCM_MMAP)
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+    else
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+        oops(pcm, errno, "cannot set hw params");
+        goto fail_close;
+    }
+
+    /* get our refined hw_params */
+    config->period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+    config->period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
+    pcm->buffer_size = config->period_count * config->period_size;
+
+    if (flags & PCM_MMAP) {
+        pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
+                                PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
+        if (pcm->mmap_buffer == MAP_FAILED) {
+            oops(pcm, errno, "failed to mmap buffer %d bytes\n",
+                 pcm_frames_to_bytes(pcm, pcm->buffer_size));
+            goto fail_close;
+        }
+    }
+
+    memset(&sparams, 0, sizeof(sparams));
+    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_ENABLE;
+    sparams.period_step = 1;
+
+    if (!config->start_threshold) {
+        if (pcm->flags & PCM_IN)
+            pcm->config.start_threshold = sparams.start_threshold = 1;
+        else
+            pcm->config.start_threshold = sparams.start_threshold =
+                config->period_count * config->period_size / 2;
+    } else
+        sparams.start_threshold = config->start_threshold;
+
+    /* pick a high stop threshold - todo: does this need further tuning */
+    if (!config->stop_threshold) {
+        if (pcm->flags & PCM_IN)
+            pcm->config.stop_threshold = sparams.stop_threshold =
+                config->period_count * config->period_size * 10;
+        else
+            pcm->config.stop_threshold = sparams.stop_threshold =
+                config->period_count * config->period_size;
+    }
+    else
+        sparams.stop_threshold = config->stop_threshold;
+
+    if (!pcm->config.avail_min) {
+        if (pcm->flags & PCM_MMAP)
+            pcm->config.avail_min = sparams.avail_min = pcm->config.period_size;
+        else
+            pcm->config.avail_min = sparams.avail_min = 1;
+    } else
+        sparams.avail_min = config->avail_min;
+
+    sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
+    sparams.silence_threshold = config->silence_threshold;
+    sparams.silence_size = config->silence_size;
+    pcm->boundary = sparams.boundary = pcm->buffer_size;
+
+    while (pcm->boundary * 2 <= INT_MAX - pcm->buffer_size)
+        pcm->boundary *= 2;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
+        oops(pcm, errno, "cannot set sw params");
+        goto fail;
+    }
+
+    rc = pcm_hw_mmap_status(pcm);
+    if (rc < 0) {
+        oops(pcm, errno, "mmap status failed");
+        goto fail;
+    }
+
+#ifdef SNDRV_PCM_IOCTL_TTSTAMP
+    if (pcm->flags & PCM_MONOTONIC) {
+        int arg = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC;
+        rc = ioctl(pcm->fd, SNDRV_PCM_IOCTL_TTSTAMP, &arg);
+        if (rc < 0) {
+            oops(pcm, errno, "cannot set timestamp type");
+            goto fail;
+        }
+    }
+#endif
+
+    pcm->underruns = 0;
+    return pcm;
+
+fail:
+    if (flags & PCM_MMAP)
+        munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+fail_close:
+    close(pcm->fd);
+    pcm->fd = -1;
+    return pcm;
+}
+
+int pcm_is_ready(struct pcm *pcm)
+{
+    return pcm->fd >= 0;
+}
+
+int pcm_prepare(struct pcm *pcm)
+{
+    if (pcm->prepared)
+        return 0;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE) < 0)
+        return oops(pcm, errno, "cannot prepare channel");
+
+    pcm->prepared = 1;
+    return 0;
+}
+
+int pcm_start(struct pcm *pcm)
+{
+    int prepare_error = pcm_prepare(pcm);
+    if (prepare_error)
+        return prepare_error;
+
+    if (pcm->flags & PCM_MMAP)
+	    pcm_sync_ptr(pcm, 0);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START) < 0)
+        return oops(pcm, errno, "cannot start channel");
+
+    pcm->running = 1;
+    return 0;
+}
+
+int pcm_stop(struct pcm *pcm)
+{
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DROP) < 0)
+        return oops(pcm, errno, "cannot stop channel");
+
+    pcm->prepared = 0;
+    pcm->running = 0;
+    return 0;
+}
+
+static inline int pcm_mmap_playback_avail(struct pcm *pcm)
+{
+    int avail;
+
+    avail = pcm->mmap_status->hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
+
+    if (avail < 0)
+        avail += pcm->boundary;
+    else if (avail > (int)pcm->boundary)
+        avail -= pcm->boundary;
+
+    return avail;
+}
+
+static inline int pcm_mmap_capture_avail(struct pcm *pcm)
+{
+    int avail = pcm->mmap_status->hw_ptr - pcm->mmap_control->appl_ptr;
+    if (avail < 0)
+        avail += pcm->boundary;
+    return avail;
+}
+
+int pcm_mmap_avail(struct pcm *pcm)
+{
+    pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
+    if (pcm->flags & PCM_IN)
+        return pcm_mmap_capture_avail(pcm);
+    else
+        return pcm_mmap_playback_avail(pcm);
+}
+
+static void pcm_mmap_appl_forward(struct pcm *pcm, int frames)
+{
+    unsigned int appl_ptr = pcm->mmap_control->appl_ptr;
+    appl_ptr += frames;
+
+    /* check for boundary wrap */
+    if (appl_ptr > pcm->boundary)
+         appl_ptr -= pcm->boundary;
+    pcm->mmap_control->appl_ptr = appl_ptr;
+}
+
+int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
+                   unsigned int *frames)
+{
+    unsigned int continuous, copy_frames, avail;
+
+    /* return the mmap buffer */
+    *areas = pcm->mmap_buffer;
+
+    /* and the application offset in frames */
+    *offset = pcm->mmap_control->appl_ptr % pcm->buffer_size;
+
+    avail = pcm_mmap_avail(pcm);
+    if (avail > pcm->buffer_size)
+        avail = pcm->buffer_size;
+    continuous = pcm->buffer_size - *offset;
+
+    /* we can only copy frames if the are availabale and continuos */
+    copy_frames = *frames;
+    if (copy_frames > avail)
+        copy_frames = avail;
+    if (copy_frames > continuous)
+        copy_frames = continuous;
+    *frames = copy_frames;
+
+    return 0;
+}
+
+int pcm_mmap_commit(struct pcm *pcm, unsigned int offset __attribute__((unused)), unsigned int frames)
+{
+    /* update the application pointer in userspace and kernel */
+    pcm_mmap_appl_forward(pcm, frames);
+    pcm_sync_ptr(pcm, 0);
+
+    return frames;
+}
+
+int pcm_avail_update(struct pcm *pcm)
+{
+    pcm_sync_ptr(pcm, 0);
+    return pcm_mmap_avail(pcm);
+}
+
+int pcm_state(struct pcm *pcm)
+{
+    int err = pcm_sync_ptr(pcm, 0);
+    if (err < 0)
+        return err;
+
+    return pcm->mmap_status->state;
+}
+
+int pcm_set_avail_min(struct pcm *pcm, int avail_min)
+{
+    if ((~pcm->flags) & (PCM_MMAP | PCM_NOIRQ))
+        return -ENOSYS;
+
+    pcm->config.avail_min = avail_min;
+    return 0;
+}
+
+int pcm_wait(struct pcm *pcm, int timeout)
+{
+    struct pollfd pfd;
+    int err;
+
+    pfd.fd = pcm->fd;
+    pfd.events = POLLOUT | POLLERR | POLLNVAL;
+
+    do {
+        /* let's wait for avail or timeout */
+        err = poll(&pfd, 1, timeout);
+        if (err < 0)
+            return -errno;
+
+        /* timeout ? */
+        if (err == 0)
+            return 0;
+
+        /* have we been interrupted ? */
+        if (errno == -EINTR)
+            continue;
+
+        /* check for any errors */
+        if (pfd.revents & (POLLERR | POLLNVAL)) {
+            switch (pcm_state(pcm)) {
+            case PCM_STATE_XRUN:
+                return -EPIPE;
+            case PCM_STATE_SUSPENDED:
+                return -ESTRPIPE;
+            case PCM_STATE_DISCONNECTED:
+                return -ENODEV;
+            default:
+                return -EIO;
+            }
+        }
+    /* poll again if fd not ready for IO */
+    } while (!(pfd.revents & (POLLIN | POLLOUT)));
+
+    return 1;
+}
+
+int pcm_get_poll_fd(struct pcm *pcm)
+{
+    return pcm->fd;
+}
+
+int pcm_mmap_transfer(struct pcm *pcm, const void *buffer, unsigned int bytes)
+{
+    int err = 0, frames, avail;
+    unsigned int offset = 0, count;
+
+    if (bytes == 0)
+        return 0;
+
+    count = pcm_bytes_to_frames(pcm, bytes);
+
+    while (count > 0) {
+
+        /* get the available space for writing new frames */
+        avail = pcm_avail_update(pcm);
+        if (avail < 0) {
+            fprintf(stderr, "cannot determine available mmap frames");
+            return err;
+        }
+
+        /* start the audio if we reach the threshold */
+	    if (!pcm->running &&
+            (pcm->buffer_size - avail) >= pcm->config.start_threshold) {
+            if (pcm_start(pcm) < 0) {
+               fprintf(stderr, "start error: hw 0x%x app 0x%x avail 0x%x\n",
+                    (unsigned int)pcm->mmap_status->hw_ptr,
+                    (unsigned int)pcm->mmap_control->appl_ptr,
+                    avail);
+                return -errno;
+            }
+            pcm->wait_for_avail_min = 0;
+        }
+
+        /* sleep until we have space to write new frames */
+        if (pcm->running) {
+            /* enable waiting for avail_min threshold when less frames than we have to write
+             * are available. */
+            if (!pcm->wait_for_avail_min && (count > (unsigned int)avail))
+                pcm->wait_for_avail_min = 1;
+
+            if (pcm->wait_for_avail_min && (avail < pcm->config.avail_min)) {
+                int time = -1;
+
+                /* disable waiting for avail_min threshold to allow small amounts of data to be
+                 * written without waiting as long as there is enough room in buffer. */
+                pcm->wait_for_avail_min = 0;
+
+                if (pcm->flags & PCM_NOIRQ)
+                    time = (pcm->config.avail_min - avail) / pcm->noirq_frames_per_msec;
+
+                err = pcm_wait(pcm, time);
+                if (err < 0) {
+                    pcm->prepared = 0;
+                    pcm->running = 0;
+                    oops(pcm, errno, "wait error: hw 0x%x app 0x%x avail 0x%x\n",
+                        (unsigned int)pcm->mmap_status->hw_ptr,
+                        (unsigned int)pcm->mmap_control->appl_ptr,
+                        avail);
+                    pcm->mmap_control->appl_ptr = 0;
+                    return err;
+                }
+                continue;
+            }
+        }
+
+        frames = count;
+        if (frames > avail)
+            frames = avail;
+
+        if (!frames)
+            break;
+
+        /* copy frames from buffer */
+        frames = pcm_mmap_transfer_areas(pcm, (void *)buffer, offset, frames);
+        if (frames < 0) {
+            fprintf(stderr, "write error: hw 0x%x app 0x%x avail 0x%x\n",
+                    (unsigned int)pcm->mmap_status->hw_ptr,
+                    (unsigned int)pcm->mmap_control->appl_ptr,
+                    avail);
+            return frames;
+        }
+
+        offset += frames;
+        count -= frames;
+    }
+
+    return 0;
+}
+
+int pcm_mmap_write(struct pcm *pcm, const void *data, unsigned int count)
+{
+    if ((~pcm->flags) & (PCM_OUT | PCM_MMAP))
+        return -ENOSYS;
+
+    return pcm_mmap_transfer(pcm, (void *)data, count);
+}
+
+int pcm_mmap_read(struct pcm *pcm, void *data, unsigned int count)
+{
+    if ((~pcm->flags) & (PCM_IN | PCM_MMAP))
+        return -ENOSYS;
+
+    return pcm_mmap_transfer(pcm, data, count);
+}
+
+int pcm_ioctl(struct pcm *pcm, int request, ...)
+{
+    va_list ap;
+    void * arg;
+
+    if (!pcm_is_ready(pcm))
+        return -1;
+
+    va_start(ap, request);
+    arg = va_arg(ap, void *);
+    va_end(ap);
+
+    return ioctl(pcm->fd, request, arg);
+}
-- 
1.9.1

